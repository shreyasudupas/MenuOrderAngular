import { HttpClient } from '@angular/common/http';
import { Component, Input, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { ActivatedRoute } from '@angular/router';
import { RegistrationProgress, Vendor } from 'src/app/admin/components/vendor/vendor';
import { validateCoordinates } from 'src/app/common/customFromValidators/validateCoorodinates';
import { LocationService } from 'src/app/common/services/location.service';
import { VendorService } from 'src/app/common/services/vendor.service';
import { environment } from 'src/environments/environment';

@Component({
    selector: 'vendor-pre-registration',
    templateUrl: './vendor-pre-registration.component.html',
    styleUrls: ['./vendor-pre-registration.component.scss']
})

export class VendorPreRegistrationComponent implements OnInit {
    vendorId:string;
    vendorTypeOptions:any[];
    latitude:number;
    longitude:number;
    
    vendorPreRegistrationForm:FormGroup;

    constructor(private http:HttpClient,
        private fb:FormBuilder,
        private locationService:LocationService,
        private activatedRoute:ActivatedRoute,
        private vendorService:VendorService) {}

    ngOnInit(): void {

        this.vendorId = this.activatedRoute.snapshot.params['vendorId'];

        this.vendorPreRegistrationForm = this.fb.group({
            id:[''],
            vendorName: ['',Validators.required],
            vendorDescription: ['',Validators.required],
            vendorType: ['',Validators.required],
            latitude:['0',[Validators.required,validateCoordinates()]],
            longitude:['0',[Validators.required,validateCoordinates()]],
            addressLine1:['',Validators.required],
            state:[{ value:'',disabled:true},Validators.required],
            city: [{ value:'',disabled:true},Validators.required],
            area: [{ value:'',disabled:true},Validators.required],
            openTime: [new Date()],
            closeTime: [new Date()],
        });

        this.vendorTypeOptions = [
            { label:'Online' , value: 'Online' },
            { label:'Offline' , value: 'Offline' },
            { label:'Online & Offline' , value: 'Online & Offline' }
        ];

        if(this.vendorId === '0') {
            this.updateVendorCoordinates();
        }
    }

    getLatLongFromUserSelection(latLong:any) {
        this.vendorPreRegistrationForm.patchValue({
            latitude: latLong.latitude,
            longitude: latLong.longitude
        });
    }

    updateVendorCoordinates() {
        this.locationService.getLocationFromUserBrowser();

        //then subscribe to the event once user location is updated
        this.locationService.getUserLocationUpdate().subscribe({
            next: result => {

                if(result !== undefined){
                    this.latitude = result.latitude;
                    this.longitude = result.longitude;
                }

            },
            error: err => {
                console.log('Update Vendor Coorindates has encountred an error ',err);
            }
        })
    }

    async getAutoGeneratedAddress() {
        if(this.vendorPreRegistrationForm.controls['latitude'].errors === null && this.vendorPreRegistrationForm.controls['longitude'].errors === null){
            const lat = this.vendorPreRegistrationForm.controls['latitude'].value;
            const long = this.vendorPreRegistrationForm.controls['longitude'].value;

            if(lat !== '0' && long !== '0'){
                var result = await this.locationService.searchUserLocationByCoordinates(lat,long);

                if(result.error !== undefined){
                    alert('Auto Generated address have recieved incorrect lattitude and longtitude');
                } else {

                    //update cities,state and area dropdown
                    this.updateStateAssociations(result.address.state,result.address.city,result.address.suburb);

                    this.vendorPreRegistrationForm.patchValue({
                        addressLine1: result.display_name,
                        state: result.address.state,
                        city: result.address.city,
                        area: result.address.suburb
                    });
                }
            }
        }
    }

    updateStateAssociations(stateName:string,cityName:string,areaName:string) {
        let url = environment.auth.idpAuthority + '/api/utility/addressAssociations';
        let body = {
            state: stateName,
            city: cityName,
            area: areaName
        };
        
        this.http.post(url,body).subscribe({
            next: result => {
                console.log('Address association update complete');
            },
            error: err => {
                console.log('Address Association encountered error ',err);
            }
        });
    }

    saveSubmit() {
        if(this.vendorPreRegistrationForm.valid) {
            if(this.vendorPreRegistrationForm.controls['state'].value === '' || this.vendorPreRegistrationForm.controls['city'].value === ''
            || this.vendorPreRegistrationForm.controls['area'].value === '') {
                alert('Enter Address fields');
                return;
            } else {
                var formValue = this.vendorPreRegistrationForm.value;

                var vendor:Vendor = {
                    id:'',
                    vendorName: formValue.vendorName,
                    vendorDescription: formValue.vendorDescription,
                    vendorType: formValue.vendorType.value,
                    state: formValue.state,
                    city: formValue.city,
                    area: formValue.area,
                    addressLine1: formValue.addressLine1,
                    addressLine2: '',
                    openTime: formValue.openTime.toTimeString().split(' ')[0],
                    closeTime: formValue.closeTime.toTimeString().split(' ')[0],
                    active: false,
                    categories:[],
                    coordinates: {
                        latitude: formValue.latitude,
                        longitude: formValue.longitude,
                    },
                    cuisineType:[],
                    image: {
                        imageFileName:'',
                        imageId:''
                    },
                    rating:0,
                    registrationProcess: RegistrationProgress.InProgress.toString()
                };

                this.addVendorDetail(vendor);
            }

        } else {
            alert('Enter required fields');
        }
    }

    addVendorDetail(vendor:Vendor) {
        this.vendorService.addVendor(vendor).subscribe({
            next: result => {
                if(result === null) {
                    alert('Unable to save the vendor data');
                } else {
                    window.history.replaceState({}, '', `vendor/vendor-pre-registration/${result.id}`);

                    this.vendorPreRegistrationForm.patchValue({
                        id: result.id
                    });
                }
            },
            error: error => console.log('Error occured in Adding the Vendor',error)
        });
    }

    editVendorDetail(vendor:Vendor) {
        this.vendorService.editVendor(vendor).subscribe({
            next: result => {
                if(result === null) {
                    alert('Unable to save the edit vendor data');
                }
            },
            error: error => console.log('Error occured in Edit Vendor',error)
        });
    }
}